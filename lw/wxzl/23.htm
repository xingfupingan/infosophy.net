<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>欢迎光临[信息哲学与自由软件]网站：infosophy.net</title>
<style>
a{text-decoration:none}
</style>
</head>

<body bgcolor="#000000" style="letter-spacing:.05em;line-height:2em">
<table width=100%>
<tr>
<td width=35% style="filter:shadow(color=lime,direction=60)">
<font color="#FFFF00">欢迎光临，信息哲学与自由软件网站！</font></td>
<td width=30%>
<p align="right"><font size="2" color="#FFFFFF"><</font><font color="#0000FF" size="2"><b><a href="22.htm">上一页</a></b></font><font size="2" color="#FFFFFF">&gt;&nbsp;&nbsp;本页为第</font><font size="2" color="#FFFF00">26</font><font size="2" color="#FFFFFF">页      
<</font><font color="#0000FF" size="2"><b><a href="24.htm">下一页</a></b></font><font size="2" color="#FFFFFF">&gt;</font><td width=10%>
<p align="right"><font color="#FFFFFF"><font size="2">[</font></font><font size="2"><a href="../../index.htm"><font color="#FFCC00"><i>返回主页</i></font></a></font><font size="2" color="#FFFFFF">]</font></td>
</td>
</table>
<hr style="margin-top:-10pt">
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">新的</span><span lang="EN-US" style="font-size: 12pt">C</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">编译器是今年春天以来我已写成的一个东西。最终我决定抛弃</span><span lang="EN-US" style="font-size: 12pt">PASTEL</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">。新的</span><span lang="EN-US" style="font-size: 12pt">C</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">编译器采用的一些思路部分取自</span><span lang="EN-US" style="font-size: 12pt">PASTEL</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，部分取自亚利桑那大学简易程序优化器</span></font><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman"><font color="#FF0000">（译注：这里的记录原文可能有误：</font></span><font color="#FF0000"><span lang="EN-US" style="font-size: 12pt">from  
the University of Arizona Portable Optimizer</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，应该是</span><span lang="EN-US" style="font-size: 12pt">from  
the Portable Optimizer of the University of Arizona</span></font><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman"><font color="#FF0000">，我们根据上下文的逻辑来进行校正翻译。本文中有较多这样的错误，就不一一注释列举了
）</font><font color="#00FFFF">。它们让人感兴趣的思路是，只要目标机器允许，它就通过产生简单的指令、并结合几条简单指令为一条复杂指令，来操作很多不同类型的机器。为统一地做到这点，他们用代数符号表示指令。例如，一条加法指令可能被表示成这样：</font></span><font color="#00FFFF"><span lang="EN-US" style="font-size: 12pt"><o:p> 
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><span lang="EN-US" style="font-size: 12pt"><font color="#00FFFF"><span style="mso-spacerun: yes">&nbsp; 
</span>r[3]=r[2]+4<o:p>
</o:p> 
<o:p>&nbsp;</o:p></font></span></p>
<p class="MsoNormal"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">这在他们的编译器内，可以是对“取寄存器</span><span lang="EN-US" style="font-size: 12pt">2</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的内容，加上</span><span lang="EN-US" style="font-size: 12pt">4</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">并将其（结果）存入寄存器</span><span lang="EN-US" style="font-size: 12pt">3</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”指令的一个表示。用这种办法，你可以对任何机器表示任何可能的指令。他们事实上也的确用此方法表示所有的指令，然后就到了设法结合它们（这些指令）的时候，他们会通过把一条指令替换为另一个，为结合的指令生成一个更复杂的代数表达式来做到这点。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">有时，依赖于第一条指令的结果是否有更多的用处，可能需要构成一个带两个赋值运算符（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">assignment  
operator</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）的结合指令。一个赋值算符对应这个值，（原注：（讲演者）指示某物）而另一个带有这个用来自第二条指令的东西替换的值（原注：（讲演者）指示某物）。但如果这个值只被使用一次，那你可以在替换它之后消去它；没必要再计算它。因此，正确地做到控制插入指令不改变任何这些值</span><span lang="EN-US" style="font-size: 12pt">,</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">和其他这类东西的的替换，实际上有点复杂。当你持续进行像自动增量和自动减量寻址（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">auto-increment  
and auto-decrement addressing</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）这类操作时――，这会儿我正在做这个――你还不得不对这类项目做各种控制，以避免你正干的事是毫无保留价值的。</span><span lang="EN-US" style="font-size: 12pt"><o:p> 
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">但在检查过所有这些东西之后，你获得替换过的结合表达式，并让它通过一个模式配对程序（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">pattern  
matcher</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">），该程序辨别接受你所选目标机器的所有正确有效的指令。如果它被识别接受，你可用一条结合的指令替换那两条，否则你就保留它们，使其各自独立。而他们的技巧就是结合二或三条被这样的数据流关联起来的指令。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">在亚利桑那编译器中，他们实际上把东西表示为像这样的文本串，而他们的编译器慢得可怕。最先我曾有某种只使用他们的编译器并在其中进行修改的想法，但后来我很清楚，我得全部重写它，以获得我需要的速度，因此，我重写了它，他它改为使用表结构来表示所有这些表达式。重写的东西像这样：</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal"><span lang="EN-US" style="font-size: 12pt"><font color="#00FFFF">&nbsp;<o:p>
</o:p> 
</font></span></p>
<p class="MsoNormal"><span lang="EN-US" style="font-size: 12pt"><font color="#00FFFF"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</span>(set (reg 2)<o:p> 
</o:p> 
</font></span></p>
<p class="MsoNormal"><span lang="EN-US" style="font-size: 12pt"><font color="#00FFFF"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</span>(+ (reg 2)<o:p> 
</o:p> 
</font></span></p>
<p class="MsoNormal" style="TEXT-INDENT: 68.25pt"><span lang="EN-US" style="font-size: 12pt"><font color="#00FFFF">(int  
4)))<o:p>
</o:p> 
</font></span></p>
<p class="MsoNormal"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">这看起来像</span><span lang="EN-US" style="font-size: 12pt">LISP</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，但其语义完全不是</span><span lang="EN-US" style="font-size: 12pt">LISP</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的，因为这儿的每个符号都要被验证。有一个业经定义的这些符号的特殊固定组――那是你需要的全部东西。</span><span style="font-size: 12pt"> 
</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">而每一个都有一个变元类型的特定模式（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">particular  
pattern of types of arguments</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">），例如：“</span><span lang="EN-US" style="font-size: 12pt">reg</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”始终有一个整型，因为寄存器是有限的，但“</span><span lang="EN-US" style="font-size: 12pt">+</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”却接受两个子表达式，等等。但伴随这些各个表达式本身的，同样也是一个数据类型，该类型基本说明了它是固定的还是浮动的（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">floating</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">），以及它的字节长度有多少。如果你需要，它也可以扩展到处理其他东西上去。</span><span lang="EN-US" style="font-size: 12pt"><o:p> 
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">我进行自动寄存器分配的方法是，在我最初生成代码和进行结合及做所有那些事时，对每个确信进入一个寄存器的变量，我都分配一个我称为伪寄存器号的东西，那是个数字，从</span><span lang="EN-US" style="font-size: 12pt">16</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，或反正是从高于你的目标机的真寄存器数开始。这样，真寄存器被计数为</span><span lang="EN-US" style="font-size: 12pt">0</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">到</span><span lang="EN-US" style="font-size: 12pt">15</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，或者到它之上（的号数）就是伪寄存器。于是，编译器的最后几个部分之一，由细致检查过的和把所有伪寄存器改变为真寄存器构成。此处，它生成一个冲突坐标图（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">conflict  
graph</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，冲突图表），它察看哪些伪寄存器在同一点上是当前有效的，而它们当然不能进入同一个真寄存器，而后，它设法把伪寄存器装入尽可能多的真寄存器，按它们重要程度的优先权安排它们。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">而到最后，它得纠正有各种问题的代码，如像在出现了有不能正确装入真寄存器的伪寄存器时，得把它改为放进栈缝（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">stack  
slots</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，栈槽）中去。当这种情形发生在特定机器上时，指令中的某一条就可能成为不合法的。例如，在</span><span lang="EN-US" style="font-size: 12pt">68000</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">上，你能把一个寄存器加进存储器，你也能把一个存储器加进寄存器，但你不能把一个存储单元（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">memory  
location</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，存储字节单元）加进另一个存储单元。因此，如果你有一个</span><span lang="EN-US" style="font-size: 12pt">ADD</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（加）指令，而你面对的是</span><span lang="EN-US" style="font-size: 12pt">68000</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，那么这两个东西都会死在机器里，它不合法。因此，这个最后的检读，按纠正那些问题的需要，仔细检查，并向寄存器中拷入和拷出东西来。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoBodyTextIndent"><font color="#00FFFF">问题也可以因索引暂存器（</font><span lang="EN-US"><font color="#FFFF99">index  
registers</font><font color="#00FFFF">，变址寄存器、指针寄存器）发生。如果你试图用某种东西进行索引，那么除开在少数情形中,你能用间接定址（</font><font color="#FFFF99">indirect 
addressing</font><font color="#00FFFF">）把它装到某些机器上外，即使索引量（</font><font color="#FFFF99">index 
quantity</font><font color="#00FFFF">）是在内存中，多数时候那代码也将成为不合法的；在你正在一个索引暂存器上做自动增量的情形中，你可能不得不复制该值到一个寄存器，执行该指令，然后把被增量的值复制回它真正该存放的内存槽。<o:p> 
</o:p> 
</font> 
</span></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">那里可以为很多细小东西获得空间，而我尚未完成那些真正有效的细小东西。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">这个编译器目前靠运行一个语法分析程序进行工作，该分析程序把</span><span lang="EN-US" style="font-size: 12pt">C</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">代码有效地转换为一个用</span><span lang="EN-US" style="font-size: 12pt">C</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">数据格式信息注释过的语法树。这时，另一检读（译注：</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">pass</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，在编译及汇编中，特指用编译及汇编程序，对源程序全面扫描，让被编译的东西通过编译器及其工具子程序（扫描、检查、优化等）考察那树并生成类似这样的（原注：类</span><span lang="EN-US" style="font-size: 12pt">LISP</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">码的）代码。接着，是几次优化检读。操作像越过转移式跳跃、到跳跃的跳跃，跳跃到点加</span><span lang="EN-US" style="font-size: 12pt">1</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">jumps  
across jumps, jumps to jumps, jumps to .+1</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）等这些东西的所有代码，能够立即被简化。接下来是一个共用子表达式识别器（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">a  
common subexpression recognizer</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">），接着是发现基本块（译注：</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">basic  
block</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，在结构化程序设计中，在</span><span lang="EN-US" style="font-size: 12pt">BEGIN</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">语句与</span><span lang="EN-US" style="font-size: 12pt">END</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">语句间，只有一个入口点和一个出口点的指令段），并执行数据流分析，以便对每条指令它都能断定出哪些值被用于该指令中、且在之后不再使用。并且也链接各指令到它使用的那些值被生成的位置，因此，如果我有一条生成伪寄存器</span><span lang="EN-US" style="font-size: 12pt">R[28]</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的指令，然后，另有一条其后要使用</span><span lang="EN-US" style="font-size: 12pt">R[28]</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的指令，我让第二条指令回指（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">point  
back to</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）第一条指令，而这一指针（指示器）被用来控制结合指令的尝试。你别结合邻近的指令（译注：意为“别因为邻近就结合”），你应把一条使用某值的指令与生成该值的指令结合。即使其间有别的指令，它们也不影响这样做，你只是得检查它们，确信它们不会做任何有干扰的事。接着，在结合器（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">combiner</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，指令结合程序）来到动态寄存器分配器（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">dynamic  
register allocator</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）之后，就是最终把它转换为汇编代码的事了。</span><span lang="EN-US" style="font-size: 12pt"><o:p> 
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">在亚利桑那编译器中，指令识别器（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">instruction  
recognizer</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）用</span><span lang="EN-US" style="font-size: 12pt">LEX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（译注：</span><span lang="EN-US" style="font-size: 12pt">LEX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">是一种程序，具体是什么程序不明）生成。你的机器描述的只是一个</span><span lang="EN-US" style="font-size: 12pt">LEX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">程序，为识别作为合法字串的指令，</span><span lang="EN-US" style="font-size: 12pt">LEX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">会转换该</span><span lang="EN-US" style="font-size: 12pt">LEX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">程序为一个</span><span lang="EN-US" style="font-size: 12pt">C</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">函数。我作的改变则是代之以一个特殊目的决策树（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">a  
special purpose decision tree</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）</span><span lang="EN-US" style="font-size: 12pt">(</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">译注：“决策树”，一套以树的形式表示的规则，每个节点处的规则经检验后产生一个相应的决定，再去执行一个特定的分支，这时或者去检验下一个规则，或者到达叶子节点，即达到最终结果</span><span lang="EN-US" style="font-size: 12pt">)</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，该树从用这个种类</span><span lang="EN-US" style="font-size: 12pt">LISP</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">语法写成的一个机器描述中生成，这种语法把机器描述得好象是</span><span lang="EN-US" style="font-size: 12pt">LISP</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">。对于该编译器的很多不同部分，这个识别器被作为一个子程序来使用。</span><span lang="EN-US" style="font-size: 12pt"><o:p> 
</o:p> 
</span></font></p>
<p class="MsoPlainText" style="TEXT-INDENT: 21pt"><span style="font-size: 12pt; mso-bidi-font-size: 10.5pt"><font color="#00FFFF">目前，这一编译器的运行差不多跟<span lang="EN-US">PCC（译注：不清楚是什么程序）一样快速。如果你告诉它不要进行细小的（</font><font color="#FFFF99">hairy</font><font color="#00FFFF">）寄存器分配，它的运行明显更快，在此情况下，它像PCC的分配方式那样分配寄存器。在它的高级细小模式（</font><font color="#FFFF99">super  
hairy mode</font><font color="#00FFFF">）中，它执行分配寄存器的任务比PCC好得多，我观察到，对于瓦克斯（VAX）机，它生成我所见过的、来自瓦克斯机上任何C编译器的最好代码。<o:p> 
</o:p> 
</font> 
</span></span></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">对于</span><span lang="EN-US" style="font-size: 12pt">68000</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（机），（生成的）代码仍不理想。因为它不能充分推算预测，所以我会看到在初段（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">early  
stages</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）进行操作不是最好的地方。它在初段有一个选择，并且它做它认为会是最好的事，只要它真的做过了另一件事，那么一个后段（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">later  
stage</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）实际上聪明得足以把事情做得甚至更好。但初段不知道后段将要做什么，因此在这些项目的有些方面，我还有很多工作要做</span><span style="font-size: 12pt"> 
</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">有时候，这导致了它不必要地释放寄存器。因为当内存中的事项结束，而它需要把它们复制进寄存器时，它需要获得寄存器。这意味着获得已被它分配了的寄存器，并把那些临时存量剔出到栈槽去。当然，这会使很多指令无效，既然那些东西是在内存，不在寄存器，因此它得一次又一次地检查。有时它认为它（本来）必需复制东西到寄存器，可实际上它又不打算这样做，因此它可能释放太多的东西</span><span lang="EN-US" style="font-size: 12pt">,</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">因而未能利用它能利用的所有寄存器。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（听众提问：你有用于</span><span lang="EN-US" style="font-size: 12pt">32000</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的代码生成器（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">code  
generator</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，代码生成程序）吗？）</span><span lang="EN-US" style="font-size: 12pt"> 
<o:p> 
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">还没有，但再说一遍，它不是个代码生成器，它只是个你需要的机器描述。一个用这种（原注：类</span><span lang="EN-US" style="font-size: 12pt">LISP</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）形式描述的全部机器指令的列表。因此，事实上，除开完成那个有关哪些变元能在寄存器中和能在哪种寄存器中、哪种东西是</span><span lang="EN-US" style="font-size: 12pt">68000</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">所需而非瓦克斯（</span><span lang="EN-US" style="font-size: 12pt">VAX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）所需等问题的约束（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">constraints</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）（译注</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">constrains</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，强迫，约束。指优化过程中，某种表示变量间关系的方程或不等式；或指某类值域的子集中的每个值必需满足的一种限制或约束）思路以外，把这个编译器从瓦克斯转换到</span><span lang="EN-US" style="font-size: 12pt">68000</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的工作只花了几天时间。因此，它非常容易转换。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">目前这个编译器生成汇编代码，且能用</span><span lang="EN-US" style="font-size: 12pt">DBX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（译注：</span><span lang="EN-US" style="font-size: 12pt">DBX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，不明。不知是否指</span><span lang="EN-US" style="font-size: 12pt">Digital  
Branch exchange</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，数字型交换机）需要的格式或用</span><span lang="EN-US" style="font-size: 12pt">GDB</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（译注：</span><span lang="EN-US" style="font-size: 12pt">GDB</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，不明。不只是否指</span><span lang="EN-US" style="font-size: 12pt">Global  
Data Base</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，全局数据库）的专用内部格式两者生成调试信息。我应该说明，仅需要在此编译器上做的工作</span><span lang="EN-US" style="font-size: 12pt">[</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">是在三个方面：一：我不得不加一个</span><span style="font-size: 12pt">  
</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">“概描”（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">profiling</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）属性，就像</span><span lang="EN-US" style="font-size: 12pt">UNIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">编译器拥有的那种东西。二：我不得不让这些寄存器分配的东西更聪明些，好让我能够不再看到出现于输出中的愚蠢玩意儿。以及三：虽然它已经正确地编译了它自身，但还有各种小毛病，即一些还不能正确操作的东西。我希望这将只花几个月时间（来纠正与完成），然后我将发布这个编译器。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">这个已存在的（</span><span lang="EN-US" style="font-size: 12pt">GNU</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）系统的另一个相当大的部分，是内核。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（听众提问：暂停一会儿？）</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">啊，是的，我想我们忘记休息了。我何不讲完有关内核的内容呢，这大概将只花五分钟，然后我们可以休息一会儿。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">现在，对于内核，我正计划使用一种叫</span><span lang="EN-US" style="font-size: 12pt">TRIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">系统――这名字不代表任何我所知道的事物，该系统曾在麻省理工作为一个研究项目被开发过。这系统是以“</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">Remote 
Procedure Call</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（远程过程</span><span lang="EN-US" style="font-size: 12pt">/</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">程序调用）”为基础的。因而程序是被调用的域（</span></font><font color="#FFFF99"><span lang="EN-US">Thus  
programs are called domains</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）。每个域是一个地址空间（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">a  
address space</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）和多种权能（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">various  
capabilities</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）。而一个权能除了是调用一个域的能力（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">ability</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）外，什么也不是。任何域都能建立“权能通道”（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">capability  
ports</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）来调用它，然后它可以通过这些通道到其他域，而在调用系统与调用另一用户域之间，没有差别。事实上，你不能区分出你调用了哪个域。因此它很容易通过其他用户程序让策略（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">devices</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）实现。一个文件系统能通过一个用户程序被透明地实现。对跨网络的通信也是透明的。你认为你正在直接调用另一个域，但其实你正在调用网络服务器域。它获取你在调用中给出的信息，并传送它到网络另一端的服务器程序，该服务器程序再调用你正试图通话的域。但你和那个另外的域，却看不到这些，它们是非可见式生成的程序。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">虽然</span><span lang="EN-US" style="font-size: 12pt">TRIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">内核一般能运行，而且它与</span><span lang="EN-US" style="font-size: 12pt">UNIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">有某种有限程度的兼容，但它还需要非常多的东西。目前它有一个在磁盘上使用相同结构的文件系统，就跟最早的</span><span lang="EN-US" style="font-size: 12pt">UNIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">文件系统的做法一样。这使它更容易调试程序，因为它们能够用</span><span lang="EN-US" style="font-size: 12pt">UNIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">建立文件，而后它们可以运行</span><span lang="EN-US" style="font-size: 12pt">TRIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">，但那个文件系统没有我认为是必需的一些属性。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">我认为必须增加的属性包括：版本号，反删除（删除恢复），文件复制到磁带的时间、方式与位置的有关信息，文件基本单元的替换（</span></font><font color="#FFFF99"><span lang="EN-US" style="font-size: 12pt">atomic  
superseding of files</span></font><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">）等。我认为，在</span><span lang="EN-US" style="font-size: 12pt">UNIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">中，当文件正被写入时，你已经能看到那儿运行的状况，这点很好，例如，你可以使用“</span><span lang="EN-US" style="font-size: 12pt">tail</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”（命令）来观看事情进展的程度，那非常好。而如果已经写了部分文件，程序死了（意外故障停机）那你仍能看到它已写出的部分。这些东西都很好，不过，那部分的编写输出不应被误认为是你期盼最终要得到的完整输出。到（那个被写了一部分的文件的）新版本被完整而正确地产生出来前，那个早先版本应该继续是可视的，并被每个尝试要使用它的人使用着。这意味着那新版本在文件系统中也应该是可视的，但不是在原先认定它该有的名字之下读取。当新版本完成写输出时，它应该被重命名。尽管那里的每个用户程序都必需明确地做这件事（重命名），但重命名是附带地在</span><span lang="EN-US" style="font-size: 12pt">ITS</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">不相容分时系统中发生的事。为使</span><span lang="EN-US" style="font-size: 12pt">UNIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">与用户程序相容，这必需隐蔽地生成。</span><span lang="EN-US" style="font-size: 12pt"><o:p> 
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">我有个奇特的计划，企图制造适合现有</span><span lang="EN-US" style="font-size: 12pt">UNIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">用户程序的版本号码。这个想法是，如果用通常的方式只指定一个文件名，那你指定文件名的版本号就是隐含的。但如果你希望精确指定一个名字，或因为你想明确声明要用什么版本，或因为你根本不要求版本――那你在（精确指定的）名字最后面放一个点。这样，如果你给出文件名“</span><span lang="EN-US" style="font-size: 12pt">FOO</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”，它表示“为</span><span lang="EN-US" style="font-size: 12pt">FOO</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">搜索既有的版本并获取最后的版本”。但如果你说“</span><span lang="EN-US" style="font-size: 12pt">FOO.</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”，则表示“只使用名字确实叫</span><span lang="EN-US" style="font-size: 12pt">FOO</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的（文件），其他不管”。如果你说“</span><span lang="EN-US" style="font-size: 12pt">FOO.3</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”那就是说“只使用名字确实为</span><span lang="EN-US" style="font-size: 12pt">FOO.3</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的文件”，这当然是</span><span lang="EN-US" style="font-size: 12pt">FOO</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">的第三版本，而其余东西不管。在输出上，如果你只说“</span><span lang="EN-US" style="font-size: 12pt">FOO</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”，它最后将建立一个“</span><span lang="EN-US" style="font-size: 12pt">FOO</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”的新版本（译注：其名字为</span><span lang="EN-US" style="font-size: 12pt">FOO.&lt;n&gt;</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">（</span><span lang="EN-US" style="font-size: 12pt">n</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">为默认版本号）），但如果你说“</span><span lang="EN-US" style="font-size: 12pt">FOO.</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”它将确切地写一个名叫“</span><span lang="EN-US" style="font-size: 12pt">FOO</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">”的文件（译注：不带版本号；但如点后有数字，则带指定版本号）。</span><span lang="EN-US" style="font-size: 12pt"><o:p>
</o:p> 
</span></font></p>
<p class="MsoNormal" style="TEXT-INDENT: 21pt"><font color="#00FFFF"><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">现在，为努力使它获得（与上述功能）相同的动作，面临着一些挑战，它们涉及到解决这一问题中的所有细节，和发现有没有什么挥之不去的疑难问题、如有些</span><span lang="EN-US" style="font-size: 12pt">UNIX</span><span style="font-size: 12pt; font-family: 宋体; mso-ascii-font-family: Times New Roman; mso-hansi-font-family: Times New Roman">软件实际上会不会中断――尽管输入了它们带点的名字，等等情况。</span></font><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: black"> 
<o:p> 
</o:p> 
</span></p>
<hr>
<table width=100%>
<tr>
<td width=35% style="filter:shadow(color=lime,direction=60)">
<font color="#FFFF00">欢迎光临，信息哲学与自由软件网站！</font></td>
<td width=30%>
<p align="right"><font size="2" color="#FFFFFF"><</font><font color="#0000FF" size="2"><b><a href="22.htm">上一页</a></b></font><font size="2" color="#FFFFFF">&gt;&nbsp;&nbsp;本页为第</font><font size="2" color="#FFFF00">26</font><font size="2" color="#FFFFFF">页      
<</font><font color="#0000FF" size="2"><b><a href="24.htm">下一页</a></b></font><font size="2" color="#FFFFFF">&gt;</font><td width=10%>
<p align="right"><font size="2" color="#FFFFFF">[</font><font size="2"><a href="../../index.htm"><font color="#FFCC00"><i>返回主页</i></font></a></font><font size="2" color="#FFFFFF">]</font></td>
</table>
</body>

</html>